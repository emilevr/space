name: Build & Release
on:
  push:
    tags:
      - '*.*.*'
  workflow_dispatch:
jobs:
  lint:
    uses: ./.github/workflows/lint.yaml
  coverage:
    uses: ./.github/workflows/coverage.yaml
  benchmark:
    uses: ./.github/workflows/benchmark.yaml
  build-and-test:
    name: '${{ matrix.target }}'
    needs:
      - benchmark
      - coverage
      - lint
    runs-on: ${{ matrix.runs-on }}
    outputs:
      CALCULATED_VERSION: ${{ steps.version.outputs.CALCULATED_VERSION }}
      IS_PRE_RELEASE: ${{ steps.version.outputs.IS_PRE_RELEASE }}
      PREV_RELEASE_VERSION: ${{ steps.version.outputs.PREV_RELEASE_VERSION }}
    strategy:
      matrix:
        include:
          - runs-on: ubuntu-latest
            target: x86_64-unknown-linux-musl
          - runs-on: macos-latest
            target: x86_64-apple-darwin
          - runs-on: windows-latest
            target: x86_64-pc-windows-msvc
    env:
      RUST_LOG: trace
    steps:
      - uses: actions/checkout@v4
        with:
          # We set a the fetch depth so we expect BuildIt to be able to find the previous version tag.
          # A value of 0 will fetch all commits, but that is overkill.
          fetch-depth: 1000

      # We also need to fetch tags as by default no tags are fetched if fetch-depth above is greater than 0.
      # Tags are used to calculate the next version number.
      - name: Fetch tags
        run: git fetch --tags origin

      - uses: ./.github/actions/detect-and-install-rust-toolchain

      - uses: ./.github/actions/run-all-tests

      - uses: ./.github/actions/install-buildit

      - name: Set the build version
        id: version
        run: buildit version

      - name: Build binaries for packaging
        run: cargo build --release --all-features

      - name: Package for distribution (Linux and MacOS)
        if: ${{ matrix.runs-on == 'ubuntu-latest' || matrix.runs-on == 'macos-latest' }}
        run: |
          ARCHIVE_FILE_DIR=./artifacts/dist
          mkdir -p $ARCHIVE_FILE_DIR

          BIN_FILE_NAMES=(space space-bench)
          for BIN_FILE_NAME in "${BIN_FILE_NAMES[@]}"
          do
            BIN_DIR_PATH=./target/release
            BIN_FILE_PATH=./target/release/${BIN_FILE_NAME}
            ARCHIVE_FILE_NAME=${BIN_FILE_NAME}-${{ matrix.target }}.tar.gz
            ARCHIVE_FILE_PATH=${ARCHIVE_FILE_DIR}/${ARCHIVE_FILE_NAME}
            ACHIVE_HASH_FILE_NAME=${ARCHIVE_FILE_NAME}.sha256

            echo "Stripping debug symbols from ${BIN_FILE_PATH}"
            strip ${BIN_FILE_PATH}

            echo "Compressing ${BIN_FILE_PATH} to ${ARCHIVE_FILE_PATH}"
            tar -C $BIN_DIR_PATH -czf $ARCHIVE_FILE_PATH $BIN_FILE_NAME

            pushd $ARCHIVE_FILE_DIR > /dev/null

            echo "Calculating SHA256 hash of ${ARCHIVE_FILE_NAME} to ${ACHIVE_HASH_FILE_NAME}"
            shasum -a 256 $ARCHIVE_FILE_NAME > $ACHIVE_HASH_FILE_NAME

            popd > /dev/null
          done

      - name: Package for distribution (Windows)
        if: ${{ matrix.runs-on == 'windows-latest' }}
        run: |
          New-Item -Type Directory -Path ./artifacts/dist -Force

          $binFileNames = @('space', 'space-bench')
          foreach ($fileName in $binFileNames) {
            $binFilePath = "./target/release/${fileName}.exe"
            $archiveFilePath = "./artifacts/dist/${fileName}-${{ matrix.target }}.zip"
            $archiveHashFilePath = "${archiveFilePath}.sha256"

            Write-Host "Compressing ${binFilePath} to ${archiveFilePath}"
            $compress = @{
              Path = $binFilePath
              DestinationPath = $archiveFilePath
              CompressionLevel = "Optimal"
            }
            Compress-Archive @compress

            Write-Host "Calculating SHA256 of ${archiveFilePath} to ${archiveHashFilePath}"
            Get-FileHash -Path $archiveFilePath -Algorithm SHA256 `
              | Select-Object @{Label='Hash';Expression={$_.Hash.ToLower()}} `
              | Select-Object -ExpandProperty Hash `
              > $archiveHashFilePath
          }

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist-${{ matrix.target }}
          path: ./artifacts/dist

  create-release:
    name: Create release
    needs: build-and-test
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
      CALCULATED_VERSION: ${{ needs.build-and-test.outputs.CALCULATED_VERSION }}
      IS_PRE_RELEASE: ${{ needs.build-and-test.outputs.IS_PRE_RELEASE }}
      PREV_RELEASE_VERSION: ${{ needs.build-and-test.outputs.PREV_RELEASE_VERSION }}
    permissions:
      contents: write # Allow release creation
    steps:
      - uses: actions/checkout@v4
        with:
          # We set a the fetch depth so we expect minver_rs to be able to find the last version tag.
          # A value of 0 will fetch all commits, but that is overkill.
          fetch-depth: 1000

      - name: Download all workflow run artifacts
        uses: actions/download-artifact@v3

      - name: Create release
        shell: pwsh
        run: |
          $isPreReleaseVar = '${{ env.IS_PRE_RELEASE }}'
          $prevReleaseVersion = '${{ env.PREV_RELEASE_VERSION }}'
          $calculatedVersion = '${{ env.CALCULATED_VERSION }}'

          Write-Host "IS_PRE_RELEASE = $isPreReleaseVar"
          Write-Host "PREV_RELEASE_VERSION = $prevReleaseVersion"
          Write-Host "CALCULATED_VERSION = $calculatedVersion"

          $isPreRelease = $true
          $preReleaseParam = '--prerelease'
          if ($isPreReleaseVar -eq 'false') {
            Write-Host 'This is a release'
            $isPreRelease = $false
            $preReleaseParam = $null
          } else {
            Write-Host 'This is a pre-release'
          }

          $hasPrevReleaseVersion = -not [string]::IsNullOrWhiteSpace($prevReleaseVersion)
          if ($hasPrevReleaseVersion) {
            Write-Host "Will create release $calculatedVersion from tag $prevReleaseVersion to tag $calculatedVersion"
            gh release create $calculatedVersion $preReleaseParam --generate-notes --latest --notes-start-tag $prevReleaseVersion --title $calculatedVersion
          } else {
            Write-Host "Will create first release $calculatedVersion"
            gh release create $calculatedVersion $preReleaseParam --notes 'First release' --title $calculatedVersion
          }

          $targets = @('x86_64-unknown-linux-musl', 'x86_64-apple-darwin', 'x86_64-pc-windows-msvc')
          foreach ($target in $targets) {
            $targetArtifactsDir = "./dist-$target"
            if (Test-Path $targetArtifactsDir) {
              gh release upload $calculatedVersion $targetArtifactsDir/*
            }
          }
